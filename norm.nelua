require "io"

local base = require ".utils.base"
local sqlite = require ".utils.sqlite"

local norm = @record{}

local norm.destroy_rows = base.destroy_rows

local norm.DbKind = @enum{
  not_set = 0,
  sqlite,
  postgres,
  mysql
}

local norm.Config = @record{
  kind: norm.DbKind,
  sqlite: record{
    name: string
  },
  postgress: record{},
  mysql: record{}
}

local Db = @record{
  kind: norm.DbKind,
  sqlite_db: *sqlite.type
}

function Db:destroy()
  switch self.kind do
    case norm.DbKind.sqlite then
      sqlite.destroy(self.sqlite_db)
  end
end

function Db:table_exists(name: string): boolean
  switch self.kind do
    case norm.DbKind.sqlite then
      return sqlite.table_exists(self.sqlite_db, name)
  end
  return false
end

function Db:query(sql: string, params: hashmap(string, string)): (sequence(hashmap(string, string)), string)
  switch self.kind do
    case norm.DbKind.sqlite then
    return sqlite.query(self.sqlite_db, sql, params)
  end
  return {}, "UNREACHABLE"
end

function Db:select(sql: string, conditions: hashmap(string, string)): (sequence(hashmap(string, string)), string)
  switch self.kind do
    case norm.DbKind.sqlite then
    return sqlite.select(self.sqlite_db, sql, conditions)
  end
  return {}, "UNREACHABLE"
end

function Db:insert(
    table_name: string,
    values: hashmap(string, string),
    returning: facultative(string)
  ): (sequence(hashmap(string, string)), string)
  switch self.kind do
    case norm.DbKind.sqlite then
    return sqlite.insert(self.sqlite_db, table_name, values, returning)
  end
  return {}, "UNREACHABLE"
end

function Db:update(
    table_name: string,
    values: hashmap(string, string),
    conditions: hashmap(string, string),
    returning: facultative(string)
  ): (sequence(hashmap(string, string)), string)
  switch self.kind do
    case norm.DbKind.sqlite then
    return sqlite.update(self.sqlite_db, table_name, values, conditions, returning)
  end
  return {}, "UNREACHABLE"
end


function Db:delete(table_name: string, conditions: hashmap(string, string)): string
  switch self.kind do
    case norm.DbKind.sqlite then
    return sqlite.delete(self.sqlite_db, table_name, conditions)
  end
  return "UNREACHABLE"
end

local norm.Db = Db

function norm.new(conf: norm.Config): (norm.Db, string)
  switch conf.kind do
    case norm.DbKind.not_set then      
      return {}, "DB object not initialised"
    case norm.DbKind.sqlite then
      local sqlite_db, err = sqlite.new(conf.sqlite.name)
      if err ~= "" then return {}, err end
    return {kind = conf.kind, sqlite_db = sqlite_db}, ""
  end
  return {}, "UNREACHABLE"
end

local Schema = @record{}
local Schema.Migration = @record{
  name: string,
  fn: function(db: norm.Db): (string)
}

local Schema.ColumnOptions = @record{
  default_val: string,
  is_null: boolean,
  unique: boolean,
  primary_key: boolean
}

local Schema.ColumnType = @enum{
  not_set = 0,
  integer,
  numeric,
  real,
  text,
  blob,
  any
}

local function schema_type_tostring(st: Schema.ColumnType, opts: Schema.ColumnOptions): string
  local sb: stringbuilder
  switch st do
    case Schema.ColumnType.integer then
      sb:write("INTEGER ")
      if opts.default_val == "" and not opts.primary_key then opts.default_val = "0" end
    case Schema.ColumnType.numeric then
      sb:write("NUMERIC ")
      if opts.default_val == "" and not opts.primary_key then opts.default_val = "0" end
    case Schema.ColumnType.real then
      sb:write("REAL ")
      if opts.default_val == "" and not opts.primary_key then opts.default_val = "0" end
    case Schema.ColumnType.text then
      sb:write("TEXT ")
    case Schema.ColumnType.blob then
      sb:write("BLOB ")
    case Schema.ColumnType.any then
      sb:write("ANY ")
    else
      error("invalid Schema.Type: " .. st)
  end
  if not opts.is_null then
    sb:write("NOT NULL ")
  end
  if opts.default_val ~= "" then
    sb:write("DEFAULT " .. opts.default_val .. " ")
  end
  if opts.unique then
    sb:write("UNIQUE ")
  end
  if opts.primary_key then
    sb:write("PRIMARY KEY ")
  end
  sb:rollback(1)
  return sb:promote()
end

local function db_run(db: Db, sql: string): string
  switch db.kind do
    case norm.DbKind.sqlite then
      return sqlite.run(db.sqlite_db, sql)
    else
      return "UNREACHABLE"
  end
end

local function db_start_transaction(db: Db)
  switch db.kind do
    case norm.DbKind.sqlite then
      return sqlite.begin_transaction(db.sqlite_db)
    else
      return "UNREACHABLE"
  end
end

local function db_get_migrated(db: Db): hashmap(string, boolean)
  local migrated: hashmap(string, boolean)
  local sql = "SELECT migration FROM \"norm_migrations\""
  local query_rows, query_err = db:query(sql)
  if query_err ~= "" then
    return migrated
  end
  for _, col in ipairs(query_rows) do
    migrated[string.copy(col["migration"])] = true
  end
  base.destroy_rows(query_rows)
  return migrated
end

local function db_migrate(db: Db, migrated: hashmap(string, boolean), migrations: sequence(Schema.Migration)): (uinteger, string)
  local ran_migrations: uinteger
  defer
    migrated:destroy()
    migrations:destroy()
  end
  for _, v in ipairs(migrations) do
    if not migrated:has(v.name) then
      print("Migrating: " .. v.name)
      switch db.kind do
        case norm.DbKind.sqlite then
          local vals: hashmap(string, string)
          vals["migration"] = v.name
          sqlite.insert(db.sqlite_db, "norm_migrations", vals)
          for k in pairs(migrated) do
            k:destroy()
          end
      end
      local create_err = v.fn(db)
      if create_err ~= "" then
        return 0, create_err
      end
      ran_migrations = ran_migrations + 1
    end
  end
  return ran_migrations, ""
end

local function db_commit_or_rollback(db: Db, err: string, ran_migrations: uinteger): string
  switch db.kind do
    case norm.DbKind.sqlite then
      if err ~= "" then
        print("Failed to migrate: " .. err)
        sqlite.rollback(db.sqlite_db)
        print("Rolling back")
      else
        sqlite.commit(db.sqlite_db)
        print(("Ran %d migrations"):format(ran_migrations))
      end
  end
  return err
end

function Schema.raw(db: norm.Db, sql: string)
  return db_run(db, sql)
end

local Schema.Column = @record{
  name: string,
  type: Schema.ColumnType,
  opts: Schema.ColumnOptions
}

function Schema.create_table(db: norm.Db, name: string, columns: sequence(Schema.Column)): string
  assert(name ~= "", "table name cannot be an empty string")
  assert(#columns > 0, "Cannot have an empty list of columns")
  local sb: stringbuilder
  sb:write("CREATE TABLE IF NOT EXISTS \"" .. name .. "\" (\n")
  for i, v in ipairs(columns) do
    assert(v.name ~= "", "column name cannot be an empty string")
    sb:writef("  %s %s,\n", base.escape_identifier(v.name), schema_type_tostring(v.type, v.opts))
  end
  sb:rollback(2)
  sb:write("\n)")
  local sql = sb:promote()

  return db_run(db, sql)
end

function Schema.drop_table(db: norm.Db, name: string)
  local sql = ('DROP TABLE IF EXISTS "%s";'):format(name)
  return db_run(db, sql)
end

local Schema.IndexOpts = @record{
  where: string,
  unique: boolean,
  if_not_exists: boolean
}

function Schema.create_index(db: norm.Db, name: string, cols: sequence(string), opts: Schema.IndexOpts)
  local sb: stringbuilder
  assert(#cols > 0)
  if opts.unique then
    sb:write("CREATE UNIQUE INDEX ")
  else
    sb:write("CREATE INDEX ")
  end
  if opts.if_not_exists then
    sb:write("IF NOT EXISTS ")
  end
  sb:writef('"%s', name)
  for _, v in ipairs(cols) do
    sb:writef("_%s", v)
  end
  sb:writef("_idx\" ON %s (", base.escape_identifier(name))
  for i, v in ipairs(cols) do
    sb:write(base.escape_identifier(v))
    if not (i == #cols) then
      sb:write(", ")
    end
  end
  sb:write(")")
  if opts.where ~= "" then
    sb:write(" WHERE ", opts.where)
  end
  local final = sb:promote()
  return db_run(db, final)
end

function Schema.drop_index(db: norm.Db, name: string, cols: sequence(string))
  local sb: stringbuilder
  sb:write("DROP INDEX IF EXISTS \"")
  sb:write(name)
  for _, v in ipairs(cols) do
    sb:writef("_%s", v)
  end
  sb:writef("_idx\"")

  local final = sb:promote()
  return db_run(db, final)
end

function Schema.add_column(db: norm.Db, tbl_name: string, col: Schema.Column)
  assert(col.name ~= "", "column name cannot be an empty string")
  local sql = ("ALTER TABLE %s ADD COLUMN %s %s"):format(
    base.escape_identifier(tbl_name),
    base.escape_identifier(col.name),
    schema_type_tostring(col.type, col.opts)
  )
  return db_run(db, sql)
end

function Schema.drop_column(db: norm.Db, tbl_name: string, col_name: string)
  local sql = ("ALTER TABLE %s DROP COLUMN %s"):format(
    base.escape_identifier(tbl_name),
    base.escape_identifier(col_name)    
  )
  return db_run(db, sql)
end

function Schema.rename_column(db: norm.Db, tbl_name: string, old_col_name: string, new_col_name: string)
  local sql = ("ALTER TABLE %s RENAME COLUMN %s to %s"):format(
    base.escape_identifier(tbl_name),
    base.escape_identifier(old_col_name),    
    base.escape_identifier(new_col_name)    
  )
  return db_run(db, sql)
end

function Schema.rename_table(db: norm.Db, old_tbl_name: string, new_tbl_name: string)
  local sql = ("ALTER TABLE %s RENAME to %s"):format(
    base.escape_identifier(old_tbl_name),
    base.escape_identifier(new_tbl_name)    
  )
  return db_run(db, sql)
end

local function db_create_migration_table(db: Db)
  if not db:table_exists("norm_migrations") then
    print("Creating migrations table")
    switch db.kind do
      case norm.DbKind.sqlite then
        Schema.create_table(db, "norm_migrations", {
          {"migration", Schema.ColumnType.text, { primary_key = true }}
        })
    end
  end
end

local norm.Schema = Schema

function norm.migrate(db: norm.Db, migrations: sequence(Schema.Migration))
  print("Running migrations")
  db_create_migration_table(db)
  local err = db_start_transaction(db)
  local migrated = db_get_migrated(db)
  local ran_migrations, err = db_migrate(db, migrated, migrations)
  return db_commit_or_rollback(db, err, ran_migrations)
end

local Model = @record{
  db: Db,
  name: string,
}

local ModelInst = @record{
  db: Db,
  tbl_name: string,
  row: hashmap(string, string)
}

function Model.new(db: Db, name: string): (Model, string)
  if not db:table_exists(name) then
    return {}, ("Table `%s` does not exist in the database"):format(name)
  end
  return {
    db = db,
    name = name
  }, ""
end

function Model:find(conditions: hashmap(string, string)): (ModelInst, string)
  local sql = "* FROM " .. self.name
  local row: hashmap(string, string)
  switch self.db.kind do
    case norm.DbKind.sqlite then
      local rows, err = sqlite.find(self.db.sqlite_db, sql, conditions)
      if err ~= "" then
        return {}, err
      end
      row = rows[1]
  end
  return {
    db = self.db,
    tbl_name = self.name,
    row = row
  }, ""
end

function Model:select(conditions: hashmap(string, string)): (sequence(ModelInst), string)
  local sql = "* FROM " .. self.name
  local result: sequence(ModelInst)
  switch self.db.kind do
    case norm.DbKind.sqlite then
      local rows, err = sqlite.select(self.db.sqlite_db, sql, conditions)
      if err ~= "" then
        return {}, err
      end
      if #rows < 1 then
        return {}, "No rows were found with the query"
      end
      for _, row in ipairs(rows) do
        result:push({      
          db = self.db,
          tbl_name = self.name,
          row = row
        })
      end
  end
  return result, ""
end

function Model:create(values: hashmap(string, string), returning: facultative(string)): (ModelInst, string)
  ## if not returning.type.is_string then
    local returning = "*"
  ## end
  local rows, err = self.db:insert(self.name, values, returning)
  if err ~= "" then
    return {}, err
  end
  if #rows < 1 then
    return {}, "No rows were found with the query"
  end
  return {      
    db = self.db,
    tbl_name = self.name,
    row = rows[1]
  }, ""
end

function ModelInst:update(values: hashmap(string, string), returning: facultative(string)): (ModelInst, string)
  ## if not returning.type.is_string then
    local returning = "*"
  ## end
  local rows, err = self.db:update(self.tbl_name, values, self.row, returning)
  if err ~= "" then
    return {}, err
  end
  if #rows < 1 then
    return {}, "No rows were found with the query"
  end
  return {      
    db = self.db,
    tbl_name = self.tbl_name,
    row = rows[1]
  }, ""
end

function ModelInst:delete(): string
  return self.db:delete(self.tbl_name, self.row)
end

function ModelInst:get_col(name: string): (string, string)
  local ok, v = self.row:has_and_get(name)
  if ok then
    return v, ""
  end
  return "", "name does not exist in row"
end

local norm.Model = Model
local norm.ModelInst = ModelInst

return norm
