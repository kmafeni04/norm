--- ## norm.nelua

require "io"

require ".thirdparty.inline_map"

local base = require ".utils.base"
local sqlite = require ".utils.sqlite"
local pg = require ".utils.pg"
local mysql = require ".utils.mysql"
local logger = require ".utils.logger"
local inflect = require ".thirdparty.inflect"
local AnsiColor = require ".thirdparty.ansicolor"

--- ### norm
--- The norm module
---`
local norm = @record{}
---`

--- ### norm.destroy_rows
--- See [base.nelua](#basenelua)
---`
local norm.destroy_rows = base.destroy_rows
---`

--- ### norm.escape_identifier
--- See [base.nelua](#basenelua)
---`
local norm.escape_identifier = base.escape_identifier
---`

--- ### norm.escape_literal
--- See [base.nelua](#basenelua)
---`
local norm.escape_literal = base.escape_literal
---`

--- ### norm.DbKind
--- Enum used to specify what database is connected in the [norm.Db](#normdb) module
---`
local norm.DbKind = @enum{
  not_set = 0,
  sqlite,
  pg,
  mysql
}
---`

--- ### norm.Config
--- This record is used to configure the ORM on what database should be connected
---`
local norm.Config = @record{
  kind: norm.DbKind,
  conn: union{
    sqlite: record{
      name: string
    },
    pg: record{
      name: string,
      user: string,
      password: string,
      host: string,
      port: uinteger
    },
    mysql: record{
      name: string,
      user: string,
      password: string,
      host: string,
      port: uinteger
    }
  },
  log: logger.NotSetOrBool
}
---`

--- ### norm.Db
--- This module is a collection of functions to make queries to the database
---`
local norm.Db = @record{
  kind: norm.DbKind,
  conn: union{
    sqlite_db: *sqlite.type,
    pg_db: *pg.type,
    mysql_db: *mysql.type
  },
  log: logger.NotSetOrBool,
  models: hashmap(string, pointer) -- norm.Model
}
---`

--- ### norm.Db.new
--[[-
This function returns a new [norm.Db](#normdb) object and an error string
If no error occurs, an empty string is returned 
-]]
---`
function norm.Db.new(conf: norm.Config): (norm.Db, string)
---`
  switch conf.kind do
    case norm.DbKind.not_set then      
      return {}, "DB object not initialised"
    case norm.DbKind.sqlite then
      local sqlite_db, err = sqlite.new(conf.conn.sqlite.name)
      if err ~= "" then return {}, err end
      return {kind = conf.kind, conn = {sqlite_db = sqlite_db}, log = conf.log}, ""
    case norm.DbKind.pg then
      local info = conf.conn.pg
      info.user = info.user ~= "" and info.user or "postgres"
      info.host = info.host ~= "" and info.host or "127.0.0.1"
      info.port = info.port ~= 0 and info.port or 5432
      local conn_info = ("dbname=%s user=%s password=%s host=%s port=%s"):format(info.name, info.user, info.password, info.host, info.port)
      local pg_db, err = pg.new(conn_info)
      if err ~= "" then return {}, err end
      return {kind = conf.kind, conn= {pg_db = pg_db}, log = conf.log}, ""
    case norm.DbKind.mysql then
      local info = conf.conn.mysql
      info.user = info.user ~= "" and info.user or "root"
      info.host = info.host ~= "" and info.host or "127.0.0.1"
      info.port = info.port ~= 0 and info.port or 3306
      local mysql_db, err = mysql.new(info.host, info.user, info.password, info.name, info.port)
      if err ~= "" then return {}, err end
      return {kind = conf.kind, conn= {mysql_db = mysql_db}, log = conf.log}, ""
  end
  return {}, "UNREACHABLE DB NEW"
end


--- ### norm.Db:destroy
--- This function cleans up the memory used by the Db object
---`
function norm.Db:destroy()
---`
  switch self.kind do
    case norm.DbKind.sqlite then
      sqlite.destroy(self.conn.sqlite_db)
    case norm.DbKind.pg then
      pg.destroy(self.conn.pg_db)
  end
end

--- ### norm.Db:query
--[[-
Sends a query to the database returning a sequence(rows) of hashmap(columns) and a string
In the case of an error, a non empty string is returned describing the error
All further Db functions are constructed around this function
-]]
---`
function norm.Db:query(sql: string): (sequence(hashmap(string, string)), string)
---`
  switch self.kind do
    case norm.DbKind.sqlite then
      return sqlite.query(self.log, self.conn.sqlite_db, sql)
    case norm.DbKind.pg then
      return pg.query(self.log, self.conn.pg_db, sql)
    case norm.DbKind.mysql then
      return mysql.query(self.log, self.conn.mysql_db, sql)
  end
  return {}, "UNREACHABLE QUERY"
end

--- ### norm.Db:table_exists
--- This function checks if a table exists in the database returning a `true` if it does, `false` otherwise
---`
function norm.Db:table_exists(name: string): boolean
---`
  local sql: string
  switch self.kind do
    case norm.DbKind.sqlite then
      sql = ("SELECT \"name\" FROM sqlite_master WHERE type = 'table' AND name = %s"):format(norm.escape_literal(name))
    case norm.DbKind.pg then
      sql = ("SELECT tablename FROM pg_catalog.pg_tables WHERE tablename = %s"):format(norm.escape_literal(name))
    case norm.DbKind.mysql then
      sql = (
        "SELECT TABLE_NAME FROM information_schema.tables WHERE table_schema = DATABASE() AND TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = %s"
      ):format(norm.escape_literal(name))
    else
      error("UNKNOWN")
  end
  local rows, err = self:query(sql)
  local res = #rows > 0
  norm.destroy_rows(rows)
  return res
end

--- ### norm.Db:select
--[[-
This function at it's simplest just appends "SELECT" to a query
Optionally, you can pass `where` to the query which will append a `WHERE` clause at the end of the sql with your conditions
-]]
---`
function norm.Db:select(sql: string, where: hashmap(string, string)): (sequence(hashmap(string, string)), string)
---`
  local sb: stringbuilder
  if next(where) then
    sb:write(" WHERE ")
    for k, v in pairs(where) do
      sb:writef("%s = %s AND ", norm.escape_identifier(k), norm.escape_literal(v))
    end
    sb:rollback(#(" AND "))
  end
  local final = "SELECT " .. sql .. sb:promote()
  return self:query(final)
end

--- ### norm.Db:insert
--[[-
This function inserts `values` into the table `tbl_name` returning the specified row of columns
If `returning` is not set, and empty sequence is returned
-]]
---`
function norm.Db:insert(
    tbl_name: string,
    values: hashmap(string, string),
    returning: facultative(string)
  ): (sequence(hashmap(string, string)), string)
---`
  if tbl_name == "" then
    return {}, "`tbl_name` can not be an empty string"
  end
  if not next(values) then
    return {}, "`values` can not be an empty hashmap"
  end
  local sb: stringbuilder
  sb:writef("INSERT INTO %s (", norm.escape_identifier(tbl_name))
  for k in pairs(values) do
    sb:writef("%s, ", norm.escape_identifier(k))
  end
  sb:rollback(2)
  sb:write(")")
  sb:write(" VALUES (")
  for _, v in pairs(values) do
    sb:writef("%s, ", norm.escape_literal(v))
  end
  sb:rollback(2)
  sb:write(")")
  ## if returning.type.is_string then
    if self.kind == norm.DbKind.mysql then
      self:query(sb:promote())
      local ssb: stringbuilder
      if returning == "*" then
        ssb:writef("SELECT %s FROM %s", returning, norm.escape_identifier(tbl_name))
      else
        ssb:writef("SELECT %s FROM %s", norm.escape_identifier(returning), norm.escape_identifier(tbl_name))
      end
      ssb:write(" WHERE ")
      for k, v in pairs(values) do
        ssb:writef("%s = %s AND ", norm.escape_identifier(k), norm.escape_literal(v))
      end
      ssb:rollback(#(" AND "))
      ssb:write(" LIMIT 1")
      return self:query(ssb:promote())
    else
      if returning == "*" then
        sb:writef(" RETURNING %s", returning)
      else
        sb:writef(" RETURNING %s", norm.escape_identifier(returning))
      end
    end
  ## end
  local sql = sb:promote()
  return self:query(sql)
end

--- ### norm.Db:update
--[[-
This function attempts deletes rows from a table `tbl_name based on `conditions`, returning an error string
If condition is a string, it is appended in the `WHERE` clause directly
If condition is a hashmap, it is formatterd into a `WHERE` clause
If no error occurs, the string is empty
-]]
---`
function norm.Db:update(
    tbl_name: string,
    values: hashmap(string, string),
    conditions: overload(string, hashmap(string, string)),
    returning: facultative(string)
  ): (sequence(hashmap(string, string)), string)
---`
  if tbl_name == "" then
    return {}, "`tbl_name` can not be an empty string"
  end
  if not next(values) then
    return {}, "`values` can not be an empty hashmap"
  end
  local sb: stringbuilder
  sb:writef("UPDATE %s SET", norm.escape_identifier(tbl_name))
  for k, v in pairs(values) do
    sb:writef(" %s = %s,", norm.escape_identifier(k), norm.escape_literal(v))
  end
  sb:rollback(1)
  ## if conditions.type.is_string then
    sb:writef(" WHERE %s", conditions)
  ## elseif conditions.type.is_hashmap then
    sb:write(" WHERE")
    for k, v in pairs(conditions) do
      sb:writef(" %s = %s AND", norm.escape_identifier(k), norm.escape_literal(v))
    end
    sb:rollback(#(" AND"))
  ## end
  ## if returning.type.is_string then
    if self.kind == norm.DbKind.mysql then
      self:query(sb:promote())
      local ssb: stringbuilder
      if returning == "*" then
        ssb:writef("SELECT %s FROM %s", returning, norm.escape_identifier(tbl_name))
      else
        ssb:writef("SELECT %s FROM %s", norm.escape_identifier(returning), norm.escape_identifier(tbl_name))
      end
      if next(conditions) then
        ssb:write(" WHERE ")
        for k, v in pairs(conditions) do
          if values:has(k) then
            ssb:writef("%s = %s AND ", norm.escape_identifier(k), norm.escape_literal(values[k]))
          else
            ssb:writef("%s = %s AND ", norm.escape_identifier(k), norm.escape_literal(v))
          end
        end
        ssb:rollback(#(" AND "))
      end
      ssb:write(" LIMIT 1")
      return self:query(ssb:promote())
    else
      if returning == "*" then
        sb:writef(" RETURNING %s", returning)
      else
        sb:writef(" RETURNING %s", norm.escape_identifier(returning))
      end
    end
  ## end
  return self:query(sb:promote())
end

--- ### norm.Db:delete
--[[-
This function attempts deletes rows from a table `tbl_name based on `conditions`, returning an error string
If condition is a string, it is appended in the `WHERE` clause directly
If condition is a hashmap, it is formatterd into a `WHERE` clause
If no error occurs, the string is empty
-]]
---`
function norm.Db:delete(tbl_name: string, conditions: overload(string, hashmap(string, string))): string
---`
  if tbl_name == "" then
    return "`tbl_name` can not be an empty string"
  end
  if not next(conditions) then
    return "`conditions` can not be an empty hashmap"
  end
  local sb: stringbuilder
  sb:writef("DELETE FROM %s WHERE ", norm.escape_identifier(tbl_name))
  ## if conditions.type.is_string then
    sb:write(conditions)
  ## else
    for k, v in pairs(conditions) do
      sb:writef("%s = %s AND ", norm.escape_identifier(k), norm.escape_literal(v))
    end
    sb:rollback(#(" AND "))
  ## end
  local final = sb:promote()
  local rows, err = self:query(final)
  norm.destroy_rows(rows)
  return err
end

--- ### norm.Schema
--- This is a collection of types and function for creating and managing your database schema
---`
local norm.Schema = @record{}
---`

--- ### norm.Schema.MigrationFn
--- Type alias for what a migration function is in [norm.migrate](#normmigrate)
---`
local norm.Schema.MigrationFn = @function(db: norm.Db): string
---`

--- ### norm.Schema.ColumnOptions
--- These are options used to modify how a column is generated in [norm.Schema.Column](#normschemacolumn)
---`
local norm.Schema.ColumnOptions = @record{
  default_val: string,
  is_null: boolean,
  unique: boolean,
  primary_key: boolean
}
---`

--- ### norm.Schema.ColumnType
--- This defines the type of a column in [norm.Schema.Column](#normschemacolumn)
---`
local norm.Schema.ColumnType: type = @enum{
  not_set = 0,
  -- generic types
  integer,
  blob,
  text,
  numeric,
  real,
  varchar,
  any,
  ----------
  -- pg/mysql specific types
  timestamp,
  date,
  ----------
  -- pg specific types
  serial,
  ----------
  -- mysql specific types
  id,
  ---------
}
---`

local function schema_type_tostring(db_kind: norm.DbKind, st: norm.Schema.ColumnType, opts: norm.Schema.ColumnOptions): (string, string)
  local sb: stringbuilder
  defer sb:destroy() end
  switch st do
    case norm.Schema.ColumnType.integer then
      sb:write("INTEGER ")
    case norm.Schema.ColumnType.serial then
      if db_kind ~= norm.DbKind.pg then
        return "", "serial type is only available in postgres"
      end
      sb:write("SERIAL ")
    case norm.Schema.ColumnType.id then
      if db_kind ~= norm.DbKind.mysql then
        return "", "id type is only available in mysql"
      end
      sb:write("INTEGER AUTO_INCREMENT ")
    case norm.Schema.ColumnType.timestamp then
      if db_kind ~= norm.DbKind.mysql and db_kind ~= norm.DbKind.pg then
        return "", "timestamp type is only available in mysql and postgres"
      end
      sb:write("TIMESTAMP ")
    case norm.Schema.ColumnType.date then
      if db_kind ~= norm.DbKind.mysql and db_kind ~= norm.DbKind.pg then
        return "", "date type is only available in mysql and postgres"
      end
      sb:write("DATE ")
    case norm.Schema.ColumnType.numeric then
      sb:write("NUMERIC ")
    case norm.Schema.ColumnType.real then
      sb:write("REAL ")
    case norm.Schema.ColumnType.text then
      sb:write("TEXT ")
    case norm.Schema.ColumnType.varchar then
      sb:write("VARCHAR(255) ")
    case norm.Schema.ColumnType.blob then
      sb:write("BLOB ")
    case norm.Schema.ColumnType.any then
      sb:write("ANY ")
    else
      return "", "invalid Schema.Type: " .. st
  end
  if not opts.is_null then
    sb:write("NOT NULL ")
  end
  if opts.default_val ~= "" then
    sb:write("DEFAULT " .. opts.default_val .. " ")
  end
  if opts.unique then
    sb:write("UNIQUE ")
  end
  if opts.primary_key then
    sb:write("PRIMARY KEY ")
  end
  sb:rollback(1)
  local sql = sb:promote()
  return sql, ""
end

local function db_run(db: norm.Db, sql: string): string
  local _, err = db:query(sql)
  return err
end

local function db_start_transaction(db: norm.Db)
  switch db.kind do
    case norm.DbKind.sqlite then
      return sqlite.begin_transaction(db.conn.sqlite_db)
    case norm.DbKind.pg then
      return pg.begin_transaction(db.conn.pg_db)
    case norm.DbKind.mysql then
      return mysql.begin_transaction(db.conn.mysql_db)
  end
  return "UNREACHABLE DB RUN"
end

local function db_get_migrated(db: norm.Db): hashmap(string, boolean)
  local migrated: hashmap(string, boolean)
  local sql = 'SELECT "migration" FROM "norm_migrations"'
  local query_rows, query_err = db:query(sql)
  if query_err ~= "" then
    return migrated
  end
  for _, col in ipairs(query_rows) do
    migrated[string.copy(col["migration"])] = true
  end
  norm.destroy_rows(query_rows)
  return migrated
end

local function db_migrate(db: norm.Db, migrated: hashmap(string, boolean), migrations: hashmap(string, norm.Schema.MigrationFn)): (uinteger, string)
  local ran_migrations: uinteger
  defer
    migrated:destroy()
    migrations:destroy()
  end
  for k, v in pairs(migrations) do
    if k == "" then
      return 0, "Migration name cannot be an empty string"
    end
    if not migrated:has(k) then
      local log_str = AnsiColor.new("Migrating: "):Bright():Yellow():text() .. AnsiColor.new(k):Green():Bright():text()
      logger.log(db.log, log_str)
      local vals: hashmap(string, string)
      vals["migration"] = k
      db:insert("norm_migrations", vals)
      for m in pairs(migrated) do
        m:destroy()
      end
      local create_err = v(db)
      if create_err ~= "" then
        return 0, create_err
      end
      ran_migrations = ran_migrations + 1
    end
  end
  return ran_migrations, ""
end

local function db_commit_or_rollback(db: norm.Db, err: string, ran_migrations: uinteger): string
  switch db.kind do
    case norm.DbKind.sqlite then
      if err ~= "" then
        local log_str = AnsiColor.new("Failed to migrate: " .. err):Bright():Yellow():text()
        logger.log(db.log, log_str)
        sqlite.rollback(db.conn.sqlite_db)
        local log_str = AnsiColor.new("Rolling back"):Bright():Yellow():text()
        logger.log(db.log, log_str)
      else
        sqlite.commit(db.conn.sqlite_db)
        local log_str = AnsiColor.new(("Ran %d migrations"):format(ran_migrations)):Bright():Yellow():text()
        logger.log(db.log, log_str)
      end
    case norm.DbKind.pg then
      if err ~= "" then
        local log_str = AnsiColor.new("Failed to migrate: " .. err):Bright():Yellow():text()
        logger.log(db.log, log_str)
        pg.rollback(db.conn.pg_db)
        local log_str = AnsiColor.new("Rolling back"):Bright():Yellow():text()
        logger.log(db.log, log_str)
      else
        pg.commit(db.conn.pg_db)
        local log_str = AnsiColor.new(("Ran %d migrations"):format(ran_migrations)):Bright():Yellow():text()
        logger.log(db.log, log_str)
      end
    case norm.DbKind.mysql then
      if err ~= "" then
        local log_str = AnsiColor.new("Failed to migrate: " .. err):Bright():Yellow():text()
        logger.log(db.log, log_str)
        mysql.rollback(db.conn.mysql_db)
        local log_str = AnsiColor.new("Rolling back"):Bright():Yellow():text()
        logger.log(db.log, log_str)
      else
        mysql.commit(db.conn.mysql_db)
        local log_str = AnsiColor.new(("Ran %d migrations"):format(ran_migrations)):Bright():Yellow():text()
        logger.log(db.log, log_str)
      end
    else
      err = "UNKONWN DB KIND"
  end
  return err
end

--- ### norm.Schema.Column
--- This defines the type of a column in [norm.Schema.Column](#normschemacolumn)
---`
local norm.Schema.Column = @record{
  name: string,
  type: norm.Schema.ColumnType,
  opts: norm.Schema.ColumnOptions
}
---`

--- ### norm.Schema.create_table
--[[-
This function creates a table, `name`, with the specified `columns` returning an error string
`extra_sql` is appended before the final ) of the create query
If no error occurs, the string is empty
-]]
---`
function norm.Schema.create_table(db: norm.Db, name: string, columns: sequence(norm.Schema.Column), extra_sql: string): string
---`
  if name == "" then
    return "table name cannot be an empty string"
  end
  if #columns <= 0 then
    return "Cannot have an empty list of columns"
  end
  local sb: stringbuilder
  sb:writef("CREATE TABLE IF NOT EXISTS %s (\n", norm.escape_identifier(name))
  for i, v in ipairs(columns) do
    if v.name == "" then
      return "column name cannot be an empty string"
    end
    local val, err = schema_type_tostring(db.kind, v.type, v.opts)
    if err ~= "" then
      return err
    end
    sb:writef("  %s %s,\n", norm.escape_identifier(v.name), val)
  end
  sb:rollback(2)
  if extra_sql ~= "" then
    sb:writef(",\n %s", extra_sql)
  end
  sb:write("\n)")
  local sql = sb:promote()

  return db_run(db, sql)
end

--- ### norm.Schema.drop_table
--[[-
This function drops a table, `name`, returning an error string
If no error occurs, the string is empty
-]]
---`
function norm.Schema.drop_table(db: norm.Db, name: string): string
---`
  local sql = ('DROP TABLE IF EXISTS "%s"'):format(name)
  return db_run(db, sql)
end

--- ### norm.Schema.IndexOpts
--- These are options used to customise the create of an index in a table, see (norm.Schema.create_index)[normschemacreate_index]
---`
local norm.Schema.IndexOpts = @record{
  where: string,
  unique: boolean,
  if_not_exists: boolean
}
---`

--- ### norm.Schema.create_index
--[[-
This function adds new indexes to a table, `name`, returning an error string
It takes a list of `cols` and optional `opts` to create a new index
If no error occurs, the string is empty
-]]
---`
function norm.Schema.create_index(db: norm.Db, name: string, cols: sequence(string), opts: norm.Schema.IndexOpts): string
---`
  local sb: stringbuilder
  if #cols < 0 then
    return "cols can not be an empty sequence"
  end
  if opts.unique then
    sb:write("CREATE UNIQUE INDEX ")
  else
    sb:write("CREATE INDEX ")
  end
  if opts.if_not_exists then
    sb:write("IF NOT EXISTS ")
  end
  sb:writef('"%s', name)
  for _, v in ipairs(cols) do
    sb:writef("_%s", v)
  end
  sb:writef("_idx\" ON %s (", norm.escape_identifier(name))
  for i, v in ipairs(cols) do
    sb:write(norm.escape_identifier(v))
    if not (i == #cols) then
      sb:write(", ")
    end
  end
  sb:write(")")
  if opts.where ~= "" then
    sb:write(" WHERE ", opts.where)
  end
  local final = sb:promote()
  return db_run(db, final)
end

--- ### norm.Schema.drop_index
--[[-
This function drops an index from a table, `name`, returning an error string
It takes a list of `cols` to determine the index to drop
If no error occurs, the string is empty
-]]
---`
function norm.Schema.drop_index(db: norm.Db, name: string, cols: sequence(string)): string
---`
  local sb: stringbuilder
  sb:write("DROP INDEX IF EXISTS \"")
  sb:write(name)
  for _, v in ipairs(cols) do
    sb:writef("_%s", v)
  end
  sb:write("_idx\"")
  if db.kind == norm.DbKind.mysql then
    sb:writef(" on %s", norm.escape_identifier(name))
  end

  local final = sb:promote()
  return db_run(db, final)
end

--- ### norm.Schema.add_column
--[[-
This function adds a new `col` to a table, `tbl_name`, returning an error string
If no error occurs, the string is empty
-]]
---`
function norm.Schema.add_column(db: norm.Db, tbl_name: string, col: norm.Schema.Column): string
---`
  if col.name == "" then
    return "column name cannot be an empty string"
  end
  local val, err = schema_type_tostring(db.kind, col.type, col.opts)
  if err ~= "" then
    return err
  end
  local sql = ("ALTER TABLE %s ADD COLUMN %s %s"):format(
    norm.escape_identifier(tbl_name),
    norm.escape_identifier(col.name),
    val
  )
  return db_run(db, sql)
end

--- ### norm.Schema.drop_column
--[[-
This function drops a `col` from a table, `tbl_name`, returning an error string
If no error occurs, the string is empty
-]]
---`
function norm.Schema.drop_column(db: norm.Db, tbl_name: string, col_name: string): string
---`
  local sql = ("ALTER TABLE %s DROP COLUMN %s"):format(
    norm.escape_identifier(tbl_name),
    norm.escape_identifier(col_name)    
  )
  return db_run(db, sql)
end

--- ### norm.Schema.rename_column
--[[-
This function renames a `col` from a table, `tbl_name`, replacing the `old_col_name` with the `new_col_name`, returning an error string
If no error occurs, the string is empty
-]]
---`
function norm.Schema.rename_column(db: norm.Db, tbl_name: string, old_col_name: string, new_col_name: string): string
---`
  local sql = ("ALTER TABLE %s RENAME COLUMN %s to %s"):format(
    norm.escape_identifier(tbl_name),
    norm.escape_identifier(old_col_name),    
    norm.escape_identifier(new_col_name)    
  )
  return db_run(db, sql)
end

--- ### norm.Schema.rename_table
--[[-
This function renames a table replacing the `old_tbl_name` with the `new_tbl_name`, returning an error string
If no error occurs, the string is empty
-]]
---`
function norm.Schema.rename_table(db: norm.Db, old_tbl_name: string, new_tbl_name: string): string
---`
  local sql = ("ALTER TABLE %s RENAME to %s"):format(
    norm.escape_identifier(old_tbl_name),
    norm.escape_identifier(new_tbl_name)    
  )
  return db_run(db, sql)
end

--- ### norm.migrate
--[[-
This function runs all `migrations`, returning an error string
If no error occurs, the string is empty
-]]
---`
function norm.migrate(db: norm.Db, migrations: hashmap(string, norm.Schema.MigrationFn)): string
---`
  local log_str = AnsiColor.new("Running migrations"):Bright():Yellow():text()
  logger.log(db.log, log_str)
  if not db:table_exists("norm_migrations") then
    local log_str = AnsiColor.new("Migrations table does not exist"):Bright():Yellow():text()
    logger.log(db.log, log_str)
    local log_str = AnsiColor.new("Creating migrations table"):Bright():Yellow():text()
    logger.log(db.log, log_str)
    local err = norm.Schema.create_table(db, "norm_migrations", {
      {"migration", norm.Schema.ColumnType.varchar, { primary_key = true }}
    })
    if err ~= "" then
      return err
    end
  end
  local err = db_start_transaction(db)
  local migrated = db_get_migrated(db)
  local ran_migrations, err = db_migrate(db, migrated, migrations)
  return db_commit_or_rollback(db, err, ran_migrations)
end

--- ### norm.RelationKind
--- This enum is used to determine the type of relation in [norm.Relation](#normrelation)
---`
local norm.RelationKind = @enum{
  not_set = 0,
  belongs_to,
  has_one,
  has_many
}
---`

--- ### norm.Relation
--[[-
This record is used to define new relations for a [model](#normmodel)
-]]
---`
local norm.Relation = @record{
  kind: norm.RelationKind,
  rel: record{
    name: string,
    model_name: string,
    key: string
  }
}
---`

--- ### norm.ModelOpts
--[[-
This is used to configure extra options for a [model](#normmodel) instance

- `primary_keys`: By default all models expect the table to have a primary key called "id" at index 1.
  This can be changed by setting the primary_keys value here
- `rels`: A sequence of defined relations used to connect models
-]]
---`
local norm.ModelOpts = @record{
  primary_keys: sequence(string),
  rels: sequence(norm.Relation)
}
---`

--- ### norm.Model
--- This is used to interact with a particular table directly with more specific functions
---`
local norm.Model = @record{
  db: *norm.Db,
  model_name: string,
  tbl_name: string,
  primary_keys: sequence(string),
  rels: sequence(norm.Relation)
}
---`

--- ### norm.Model.Inst
--[[-
Model Instance
This is meant to represent a single row in a model's table
-]]
---`
local norm.Model.Inst = @record{
  parent: *norm.Model,
  row: hashmap(string, string)
}
---`

--- ### norm.Model.new
--[[-
This function returns a new Model object and an error string
If no error occurs, the string is empty

This function allocates memory for the model as it needs to be stored as a pointer in the [db](#normdb) instance to be used with relations
Maked sure to call [Model:destroy](#normmodeldestroy) to clear it out from the db before trying to create a new one with similar relations
-]]
---`
function norm.Model.new(db: *norm.Db, tbl_name: string, model_name: string, opts: norm.ModelOpts): (*norm.Model, string)
---`
  if not db then
    return nilptr, "`db` can not be a nilptr"
  end
  if not db:table_exists(tbl_name) then
    return nilptr, ("Table `%s` does not exist in the database"):format((tbl_name))
  end
  if model_name == "" then
    return nilptr, "Model name can not be empty"
  end
  if db.models:has(model_name) then
    return nilptr, ("Model `%s` already exists on this Db instance"):format(model_name)
  end
  local primary_keys: sequence(string)
  if #opts.primary_keys < 1 then
    primary_keys:push("id")
  else
    primary_keys = opts.primary_keys
  end
  local model = new(norm.Model)
  $model = {
    db = db,
    model_name = model_name,
    tbl_name = tbl_name,
    primary_keys = primary_keys,
    rels = opts.rels
  }
  db.models[model_name] = model
  return model, ""
end

--- ### norm.Model:destroy
--- Used to clean up memory created by the model and clear it from the model cache in the db instance
---`
function norm.Model:destroy()
---`
  self.db.models:remove(self.model_name)
  delete(self)
end

--- ### norm.Model:find
--[[-
This function attempts to find a row based on the `conditions`, returning a [norm.model.Inst](#normmodelinst) object and an error string
If condition is a string, it is appended in a `WHERE` clause directly
If condition is a hashmap, it is formatterd into a `WHERE` clause
If no error occurs, the string is empty
-]]
---`
function norm.Model:find(conditions: overload(string, hashmap(string, string))): (norm.Model.Inst, string)
---`
  local sb: stringbuilder
  sb:writef("SELECT * FROM %s ", norm.escape_identifier(self.tbl_name))
  local row: hashmap(string, string)
  ## if conditions.type.is_string then
    sb:writef(" WHERE %s", conditions)
  ## elseif conditions.type.is_hashmap then
    if next(conditions) then
      sb:write(" WHERE")
      for k, v in pairs(conditions) do
        sb:writef(" %s = %s AND", norm.escape_identifier(k), norm.escape_literal(v))
      end
      sb:rollback(#(" AND"))
    end
  ## end
  sb:write(" LIMIT 1")
  local rows, err = self.db:query(sb:promote())
  if err ~= "" then
    return {}, err
  end
  row = rows[1]
  return {
    parent = self,
    row = row
  }, ""
end

--- ### norm.Model:count
--[[-
This function returns the total number of records in a model based on the provided conditions and an error string
If condition is a string, it is appended in a `WHERE` clause directly
If condition is a hashmap, it is formatterd into a `WHERE` clause
If no condition is provided then every row in the table will be counted
If no error occurs, the string is empty
-]]
---`
function norm.Model:count(conditions: overload(niltype, string, hashmap(string, string))): (integer, string)
---`
  local sb: stringbuilder
  sb:writef("SELECT COUNT(*) as count FROM %s", norm.escape_identifier(self.tbl_name))
  ## if conditions.type.is_string then
    sb:writef(" WHERE %s", conditions)
  ## elseif conditions.type.is_hashmap then
    if next(conditions) then
      sb:write(" WHERE")
      for k, v in pairs(conditions) do
        sb:writef(" %s = %s AND", norm.escape_identifier(k), norm.escape_literal(v))
      end
      sb:rollback(#(" AND"))
    end
  ## end
  local rows, err = self.db:query(sb:promote())
  if err ~= "" then
    return 0, err
  end
  return tonumber(rows[1]["count"]), ""
end

--- ### norm.Model:select
--[[-
This function attempts to find rows based on the `conditions`, returning a sequence of [norm.model.Inst](#normmodelinst) objects and an error string
If condition is a string, it is appended in a `WHERE` clause directly
If condition is a hashmap, it is formatterd into a `WHERE` clause
If no condition is provided then every row in the table will be returned
If no error occurs, the string is empty
-]]
---`
function norm.Model:select(conditions: overload(niltype, string, hashmap(string, string))): (sequence(norm.Model.Inst), string)
---`
  local sb: stringbuilder
  sb:writef("SELECT * FROM %s", norm.escape_identifier(self.tbl_name))
  ## if conditions.type.is_string then
    sb:writef(" WHERE %s", conditions)
  ## elseif conditions.type.is_hashmap then
    if next(conditions) then
      sb:write(" WHERE")
      for k, v in pairs(conditions) do
        sb:writef(" %s = %s AND", norm.escape_identifier(k), norm.escape_literal(v))
      end
      sb:rollback(#(" AND"))
    end
  ## end
  local rows, err = self.db:query(sb:promote())
  if err ~= "" then
    return {}, err
  end
  local result: sequence(norm.Model.Inst)
  for _, row in ipairs(rows) do
    result:push({      
      parent = self,
      row = row
    })
  end
  return result, ""
end

--- ### norm.Model:create
--[[-
This function inserts `values` into the model's table, returning a [norm.model.Inst](#normmodelinst) object and an error string
If `returning` is not set, and empty object is returned
If no error occurs, the string is empty
-]]
---`
function norm.Model:create(values: hashmap(string, string), returning: facultative(string)): (norm.Model.Inst, string)
---`
  if not next(values) then
    return {}, "`values` can not be an empty hashmap"
  end
  ## if not returning.type.is_string then
    local returning = "*"
  ## end
  local rows, err = self.db:insert(self.tbl_name, values, returning)
  if err ~= "" then
    return {}, err
  end
  return {      
    parent = self,
    row = rows[1]
  }, ""
end

--- ### norm.Model.Inst:get_col
--[[-
This function get's the value of the col by `name` if it exists, returning the value and an error string
If no error occurs, the string is empty
-]]
---`
function norm.Model.Inst:get_col(name: string): (string, string)
---`
  if not self.parent then
    return "", "This model instance's parent does not exist"
  end
  local ok, v = self.row:has_and_get(name)
  if not ok then
    return "", ""
  end
  return v, "" 
end

--- ### norm.Model.Inst:update
--[[-
This function updates the row instance with `values` into the model's table, returning a [norm.model.Inst](#normmodelinst) object and an error string
If `returning` is not set, and empty object is returned
If no error occurs, the string is empty
-]]
---`
function norm.Model.Inst:update(values: hashmap(string, string), returning: facultative(string)): (norm.Model.Inst, string)
---`
  if not self.parent then
    return {}, "This model instance's parent does not exist"
  end
  ## if not returning.type.is_string then
    local returning = "*"
  ## end
  local id, err = self:get_col(self.parent.primary_keys[1])
  if err ~= "" then
    return {}, "Could not match primary key in model: " .. err
  end
  local conds = inline_map!(string, string, {
    [self.parent.primary_keys[1]] = id
  })
  local rows, err = self.parent.db:update(self.parent.tbl_name, values, conds, returning)
  if err ~= "" then
    return {}, err
  end
  return {
    parent = self.parent,
    row = rows[1]
  }, ""
end

--- ### norm.Model.Inst:delete
--[[-
This function deletes the row instance from the model's table, returning an error string
If no error occurs, the string is empty
-]]
---`
function norm.Model.Inst:delete(): string
---`
  if not self.parent then
    return "This model instance's parent does not exist"
  end
  local id, err = self:get_col(self.parent.primary_keys[1])
  if err ~= "" then
    return "Could not match primary key in model: " .. err
  end
  local conds: hashmap(string, string)
  conds[self.parent.primary_keys[1]] = id
  return self.parent.db:delete(self.parent.tbl_name, conds)
end

--- ### norm.Model.Inst:get_belongs_to
--[[-
This function returns a new model instance based on the `rel_name` and an error string
If no error occurs, the string is empty

A relation that fetches a single related model instance. The foreign key column used to fetch the other model is located on the same table as the model. For example, a table named `posts` with a column named `user_id` would belong to a table named `users`.
-]]
---`
function norm.Model.Inst:get_belongs_to(rel_name: string): (norm.Model.Inst, string)
---`
  if not self.parent then
    return {}, "This model instance's parent does not exist"
  end
  for _, rel in ipairs(self.parent.rels) do
    if rel.rel.name == rel_name and rel.kind == norm.RelationKind.belongs_to then
      local rel = rel.rel
      local key: string
      if rel.key ~= "" then
        key = rel.key
      else
        key = rel.name .. "_id"
      end
      local id, err = self:get_col(key)
      if err ~= "" then
        return {}, "Could not find key on instance table: " .. err
      end
      local ok, model_ptr = self.parent.db.models:has_and_get(rel.model_name)
      if not ok then
        return {}, ("Realtion's model `%s` does not exist on this db instance"):format(rel.model_name)
      end
      if not model_ptr then
        return {}, ("Model `%s` in db instance is a nilptr"):format(rel.model_name)
      end
      local model = (@*norm.Model)(model_ptr)
      return model:find(inline_map!(string, string, {
        [model.primary_keys[1]] = id
      }))
    end
  end

  return {}, ("A matching relation was not found for `%s`"):format(rel_name)
end

--- ### norm.Model.Inst:get_has_one
--[[-
This function returns a new model instance based on the `rel_name` and an error string
If no error occurs, the string is empty

A relation that fetches a single related model. Similar to `belongs_to`, but the foreign key used to fetch the other model is located on the other table
-]]
---`
function norm.Model.Inst:get_has_one(rel_name: string): (norm.Model.Inst, string)
---`
  if not self.parent then
    return {}, "This model instance's parent does not exist"
  end
  for _, rel in ipairs(self.parent.rels) do
    if rel.rel.name == rel_name and rel.kind == norm.RelationKind.has_one then
      local rel = rel.rel
      local key: string
      if rel.key ~= "" then
        key = rel.key
      else
        key = inflect.depluralize(self.parent.tbl_name) .. "_id"
      end
      local id, err = self:get_col(self.parent.primary_keys[1])
      if err ~= "" then
        return {}, "Could not find key on instance table: " .. err
      end
      local ok, model_ptr = self.parent.db.models:has_and_get(rel.model_name)
      if not ok then
        return {}, ("Realtion's model `%s` does not exist on this db instance"):format(rel.model_name)
      end
      if not model_ptr then
        return {}, ("Model `%s` in db instance is a nilptr"):format(rel.model_name)
      end
      local model = (@*norm.Model)(model_ptr)
      return model:find(inline_map!(string, string, {
        [key] = id
      }))
    end
  end

  return {}, ("A matching relation was not found for `%s`"):format(rel_name)
end

--- ### norm.Model.Inst:get_has_one
--[[-
This function returns a sequence of new model instances based on the `rel_name` and an error string
If no error occurs, the string is empty

A relation that fetches a sequence of the related model. Similar to `has_one`, but returning multiple
-]]
---`
function norm.Model.Inst:get_has_many(rel_name: string): (sequence(norm.Model.Inst), string)
---`
  if not self.parent then
    return {}, "This model instance's parent does not exist"
  end
  for _, rel in ipairs(self.parent.rels) do
    if rel.rel.name == rel_name and rel.kind == norm.RelationKind.has_many then
      local rel = rel.rel
      local key: string
      if rel.key ~= "" then
        key = rel.key
      else
        key = inflect.depluralize(self.parent.tbl_name) .. "_id"
      end
      local id, err = self:get_col(self.parent.primary_keys[1])
      if err ~= "" then
        return {}, "Could not find key on instance table: " .. err
      end
      local ok, model_ptr = self.parent.db.models:has_and_get(rel.model_name)
      if not ok then
        return {}, ("Realtion's model `%s` does not exist on this db instance"):format(rel.model_name)
      end
      if not model_ptr then
        return {}, ("Model `%s` in db instance is a nilptr"):format(rel.model_name)
      end
      local model = (@*norm.Model)(model_ptr)
      return model:select(inline_map!(string, string, {
        [key] = id
      }))
    end
  end

  return {}, ("A matching relation was not found for `%s`"):format(rel_name)
end

return norm
