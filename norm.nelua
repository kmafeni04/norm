require "io"

local sqlite = require ".utils.sqlite"

local norm = @record{}

local norm.DbKind = @enum{
  not_set = 0,
  sqlite,
  pg,
  mysql
}

local norm.Config = @record{
  kind: norm.DbKind,
  sqlite: record{
    name: string
  },
  postgress: record{},
  mysql: record{}
}

local Db = @record{
  kind: norm.DbKind,
  sqlite_db: *sqlite.type
}

function Db:destroy()
  switch self.kind do
    case norm.DbKind.sqlite then
      sqlite.destroy(self.sqlite_db)
  end
end

local norm.Db = Db

function norm.new(conf: norm.Config): (norm.Db, string)
  switch conf.kind do
    case norm.DbKind.not_set then      
      return {}, "DB object not initialised"
    case norm.DbKind.sqlite then
      local sqlite_db, err = sqlite.new(conf.sqlite.name)
      if err ~= "" then return {}, err end
    return {kind = conf.kind, sqlite_db = sqlite_db}, ""
  end
  return {}, "UNREACHABLE"
end

local Schema = @record{}
local Schema.migration = @function(db: norm.Db): (string)

local Schema.ColumnOptions = @record{
  default_val: string,
  is_null: boolean,
  unique: boolean,
  primary_key: boolean
}

local Schema.ColumnType = @enum{
  not_set = 0,
  integer,
  numeric,
  real,
  text,
  blob,
  any
}

local function schema_type_tostring(st: Schema.ColumnType, opts: Schema.ColumnOptions): string
  local sb: stringbuilder
  switch st do
    case Schema.ColumnType.integer then
      sb:write("INTEGER ")
      if opts.default_val == "" and not opts.primary_key then opts.default_val = "0" end
    case Schema.ColumnType.numeric then
      sb:write("NUMERIC ")
      if opts.default_val == "" and not opts.primary_key then opts.default_val = "0" end
    case Schema.ColumnType.real then
      sb:write("REAL ")
      if opts.default_val == "" and not opts.primary_key then opts.default_val = "0" end
    case Schema.ColumnType.text then
      sb:write("TEXT ")
    case Schema.ColumnType.blob then
      sb:write("BLOB ")
    case Schema.ColumnType.any then
      sb:write("ANY ")
    else
      error("invalid Schema.Type: " .. st)
  end
  if not opts.is_null then
    sb:write("NOT NULL ")
  end
  if opts.default_val ~= "" then
    sb:write("DEFAULT " .. opts.default_val .. " ")
  end
  if opts.unique then
    sb:write("UNIQUE ")
  end
  if opts.primary_key then
    sb:write("PRIMARY KEY ")
  end
  sb:rollback(1)
  return sb:promote()
end

local Schema.Column = @record{
  name: string,
  type: Schema.ColumnType,
  opts: Schema.ColumnOptions
}

function Schema.create_table(db: norm.Db, name: string, columns: sequence(Schema.Column)): string
  assert(name ~= "", "table name cannot be an empty string")
  assert(#columns > 0, "Cannot have an empty list of columns")
  local sb: stringbuilder
  sb:write("CREATE TABLE IF NOT EXISTS \"" .. name .. "\" (\n")
  for i, v in ipairs(columns) do
    assert(v.name ~= "", "column name cannot be an empty string")
    sb:write(('  "%s" %s,\n'):format(v.name, schema_type_tostring(v.type, v.opts)))
  end
  sb:rollback(2)
  sb:write("\n);")
  local sql = sb:promote()
  print(sql)

  switch db.kind do
    case norm.DbKind.sqlite then
      return sqlite.create_table(db.sqlite_db, sql)
    else
      return "UNREACHABLE"
  end
end

local norm.Schema = Schema

function norm.migrate(db: norm.Db, migrations: hashmap(string, Schema.migration))
  switch db.kind do
    case norm.DbKind.sqlite then
      if not sqlite.table_exists(db.sqlite_db, "norm_migrations") then
        print("Creating migrations table")
        Schema.create_table(db, "norm_migrations", {
          {"id", Schema.ColumnType.integer, { primary_key = true }},
          {"migration", Schema.ColumnType.integer, { unique = true }}
        })
      end
  end
  switch db.kind do
    case norm.DbKind.sqlite then
      sqlite.begin_transaction(db.sqlite_db)
  end
  local err: string
  local rows: sequence(hashmap(string, string))
  local migrated: hashmap(string, boolean)
  local ran_migrations: uinteger
  switch db.kind do
    case norm.DbKind.sqlite then
    local query_rows, query_err = sqlite.query(db.sqlite_db, "SELECT migration FROM \"norm_migrations\"")
    if query_err ~= "" then
      err = query_err
      goto END
    end
    for _, col in ipairs(query_rows) do
      migrated[col["migration"]] = true
    end
    rows = query_rows
  end
  for k, v in pairs(migrations) do
    if not migrated:has(k) then
      print("Migrating: " .. k)
      switch db.kind do
        case norm.DbKind.sqlite then
          local vals: hashmap(string, string)
          vals["migration"] = k
          sqlite.insert(db.sqlite_db, "norm_migrations", vals)
      end
      local create_err = v(db)
      if create_err ~= "" then
        err = create_err
        break
      end
      ran_migrations = ran_migrations + 1
    end
  end
  ::END::
  switch db.kind do
    case norm.DbKind.sqlite then
      if err ~= "" then
        print("Failed to migrate: " .. err)
        sqlite.rollback(db.sqlite_db)
        print("Rolling back")
      else
        sqlite.commit(db.sqlite_db)
        print(("Ran %d migrations"):format(ran_migrations))
      end
  end
end

local db, err = norm.new({
  kind = norm.DbKind.sqlite,
  sqlite = {
    name = "hello.db"
  }
})

assert(err == "", err)

local migrations: hashmap(string, norm.Schema.migration)
local schema = norm.Schema
local type = schema.ColumnType
migrations["11"] = function(db: norm.Db): string
  local err = schema.create_table(db, "users", {
    {"name", type.text, { primary_key = true }},
    {"id", type.integer},
    {"balance", type.real}
  })
  if err ~= "" then
    return err
  end

  return ""
end
migrations["21"] = function(db: norm.Db): string
  local err = schema.create_table(db, "players", {
    {"name", type.text, { primary_key = true }},
    {"id", type.integer},
    {"balance", type.real}
  })
  if err ~= "" then
    return err
  end

  return ""
end

norm.migrate(db, migrations)
return
