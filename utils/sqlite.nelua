require "..libs.sqlite"
local base = require ".base"

local M = @record{}

local M.type: type = sqlite3

function M.new(name: string): (*sqlite3, string)
  local sqlite_db: *sqlite3
  local rc: cint

  if name == "" then return sqlite_db, "Database name cannot be an empty string" end

  rc = sqlite3_open(name , &sqlite_db)

  if rc ~= SQLITE_OK then
    sqlite3_close(sqlite_db)
    return sqlite_db, ("Cannot open database: %s \n"):format(sqlite3_errmsg(sqlite_db))
  end
  return sqlite_db, ""
end

function M.destroy(db: *sqlite3)
  sqlite3_close(db)
end

function M.run(db: *sqlite3, sql: string): string
  local err_msg: cstring
  print(sql)
  local rc = sqlite3_exec(db, sql, nilptr, nilptr, &err_msg)
  if rc ~= SQLITE_OK then
    local str: string = string.copy(err_msg)
    sqlite3_free(err_msg)
    return str
  end
  return ""
end

function M.begin_transaction(db: *sqlite3): string
  local err_msg: cstring
  local rc = sqlite3_exec(db, "BEGIN TRANSACTION;", nilptr, nilptr, &err_msg)
  if rc ~= SQLITE_OK then
    local str: string = string.copy(err_msg)
    sqlite3_free(err_msg)
    return str
  end
  return ""
end

function M.commit(db: *sqlite3)
  local err_msg: cstring
  local rc = sqlite3_exec(db, "COMMIT;", nilptr, nilptr, &err_msg)
  if rc ~= SQLITE_OK then
    local str: string = string.copy(err_msg)
    sqlite3_free(err_msg)
    return str
  end
  return ""
end

function M.rollback(db: *sqlite3)
  local err_msg: cstring
  local rc = sqlite3_exec(db, "ROLLBACK;", nilptr, nilptr, &err_msg)
  if rc ~= SQLITE_OK then
    local str: string = string.copy(err_msg)
    sqlite3_free(err_msg)
    return str
  end
  return ""
end

function M.query(db: *sqlite3, sql: string, params: hashmap(string, string)): (sequence(hashmap(string, string)), string)
  local rows: sequence(hashmap(string, string))
  print(sql)
  local stmt: *sqlite3_stmt
  local rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nilptr)
  if rc ~= SQLITE_OK then
    return rows, string.format("Failed to prepare statement: %s", sqlite3_errmsg(db))
  end

  defer sqlite3_finalize(stmt) end

  -- Bind named parameters
  for name, value in pairs(params) do
    -- Parameter name must include the `:` (e.g., ":username")
    local pname = ":" .. name
    local index = sqlite3_bind_parameter_index(stmt, pname)
    if index == 0 then
      return rows, string.format("Parameter '%s' not found in SQL statement.", pname)
    end

    rc = sqlite3_bind_text(stmt, index, value, -1, nilptr)
    if rc ~= SQLITE_OK then
      return rows, string.format("Failed to bind parameter '%s': %s", pname, sqlite3_errmsg(db))
    end
  end

  while true do
    rc = sqlite3_step(stmt)
    if rc ~= SQLITE_ROW then
      break
    end
    local ncols = sqlite3_column_count(stmt)
    local cols: hashmap(string, string)
    for i = 0, <ncols do
      local text: cstring = (@cstring)(sqlite3_column_text(stmt, i))
      local name: cstring = (@cstring)(sqlite3_column_name(stmt, i))
      cols[string.copy(name)] = (text ~= nilptr and string.copy(text) or "NULL")
    end
    rows:push(cols)
  end

  return rows, ""
end

function M.select(db: *sqlite3, sql: string, conditions: hashmap(string, string)): (sequence(hashmap(string, string)), string)
  local sb: stringbuilder
  if next(conditions) then
    sb:write(" WHERE ")
    for k, v in pairs(conditions) do
      sb:writef("%s = :%s AND ", base.escape_identifier(k), k)
    end
    sb:rollback(#(" AND "))
  end
  local final = "SELECT " .. sql .. sb:promote()
  return M.query(db, final, conditions)
end

function M.find(db: *sqlite3, sql: string, conditions: hashmap(string, string)): (sequence(hashmap(string, string)), string)
  local sb: stringbuilder
  if next(conditions) then
    sb:write(" WHERE ")
    for k, v in pairs(conditions) do
      sb:writef("%s = :%s AND ", base.escape_identifier(k), k)
    end
    sb:rollback(#(" AND "))
  end
  sb:write(" LIMIT 1")
  local final = "SELECT " .. sql .. sb:promote()
  return M.query(db, final, conditions)
end

function M.insert(
    db: *sqlite3,
    table_name: string,
    values: hashmap(string, string),
    returning: facultative(string)
  ): (sequence(hashmap(string, string)), string)
  local sb: stringbuilder
  sb:writef("INSERT INTO %s (", base.escape_identifier(table_name))
  for k in pairs(values) do
    sb:writef("%s, ", base.escape_identifier(k))
  end
  sb:rollback(2)
  sb:write(")")
  sb:write(" VALUES (")
  for k in pairs(values) do
    sb:writef(":%s, ", k)
  end
  sb:rollback(2)
  sb:write(")")
  ## if returning.type.is_string then
    if returning == "*" then
      sb:writef(" RETURNING %s", returning)
    else
      sb:writef(" RETURNING %s", base.escape_identifier(returning))
    end
  ## end
  local final = sb:promote()
  return M.query(db, final, values)
end

function M.update(
    db: *sqlite3,
    table_name: string,
    values: hashmap(string, string),
    conditions: hashmap(string, string),
    returning: facultative(string)
  ): (sequence(hashmap(string, string)), string)
  local sb: stringbuilder
  local final_vals: hashmap(string, string)
  sb:writef("UPDATE %s SET ", base.escape_identifier(table_name))
  for k, v in pairs(values) do
    sb:writef("%s = :val_%s, ", k, k)
    final_vals["val_".. k] = v
  end
  sb:rollback(2)
  if next(conditions) then
    sb:write(" WHERE ")
    for k, v in pairs(conditions) do
      sb:writef("%s = :cond_%s AND ", base.escape_identifier(k), k)
      final_vals["cond_".. k] = v
    end
    sb:rollback(#(" AND "))
  end
  ## if returning.type.is_string then
    if returning == "*" then
      sb:writef(" RETURNING %s", returning)
    else
      sb:writef(" RETURNING %s", base.escape_identifier(returning))
    end
  ## end
  local final = sb:promote()
  return M.query(db, final, final_vals)
end

function M.delete(db: *sqlite3, table_name: string, conditions: hashmap(string, string)): string
  local sb: stringbuilder
  sb:writef("DELETE FROM %s WHERE ", base.escape_identifier(table_name))
  for k, v in pairs(conditions) do
    sb:writef("%s = :%s AND ", base.escape_identifier(k), k)
  end
  sb:rollback(#(" AND "))
  local final = sb:promote()
  local rows, err = M.query(db, final, conditions)
  base.destroy_rows(rows)
  return err
end

function M.table_exists(db: *sqlite3, table_name: string): boolean
  local sql = ("SELECT \"name\" FROM sqlite_master WHERE type='table' AND name=%s"):format(base.escape_literal(table_name))
  local rows, err = M.query(db, sql)
  local result = #rows > 0
  base.destroy_rows(rows)
  return result
end
return M
